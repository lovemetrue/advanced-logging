input {
  file {
    path => "/var/log/app/*.log"
    start_position => "beginning"
    sincedb_path => "/dev/null"
    codec => multiline {
      pattern => "^%{TIMESTAMP_ISO8601}|^{"
      negate => true
      what => "previous"
    }
  }
}

filter {
  # Кастомные grok паттерны для сложных форматов
  grok {
    patterns_dir => ["/usr/share/logstash/patterns/custom"]
    
    # Для стандартного формата логов
    match => { 
      "message" => "%{TIMESTAMP_ISO8601:timestamp} %{LOGLEVEL:level} \[%{DATA:thread}\] %{DATA:class} - %{GREEDYDATA:message}" 
    }
    
    # Для логов с пользовательским контекстом
    match => {
      "message" => "%{TIMESTAMP_ISO8601:timestamp} %{LOGLEVEL:level} \[%{DATA:correlation_id}\] \[%{DATA:user_id}\] %{GREEDYDATA:message}"
    }
  }

  # Обработка JSON логов с вложенными объектами
  if [message] =~ /^{.*}$/ {
    json {
      source => "message"
      target => "parsed_json"
    }
    
    # Извлечение вложенных полей из сложного JSON
    if [parsed_json][context] {
      mutate {
        add_field => {
          "correlation_id" => "%{[parsed_json][context][correlation_id]}"
          "user_id" => "%{[parsed_json][context][user_id]}"
          "session_id" => "%{[parsed_json][context][session_id]}"
        }
      }
    }
    
    # Обработка ошибок с stacktrace
    if [parsed_json][exception] {
      mutate {
        add_field => {
          "exception_class" => "%{[parsed_json][exception][class]}"
          "exception_message" => "%{[parsed_json][exception][message]}"
        }
      }
    }
  }

  # Парсинг SQL запросов
  grok {
    match => { 
      "message" => "SQL: %{WORD:db_operation} %{GREEDYDATA:sql_query} \[Parameters: %{GREEDYDATA:sql_parameters}\]" 
    }
  }

  # Парсинг HTTP запросов
  grok {
    match => { 
      "message" => "%{WORD:http_method} %{URIPATH:http_path} %{NUMBER:http_status} %{NUMBER:response_time}ms" 
    }
  }

  # Валидация и нормализация данных
  if [response_time] {
    mutate {
      convert => { "response_time" => "integer" }
    }
    
    # Категоризация по производительности
    if [response_time] > 1000 {
      mutate {
        add_field => { "performance_category" => "slow" }
      }
    } else if [response_time] > 500 {
      mutate {
        add_field => { "performance_category" => "medium" }
      }
    } else {
      mutate {
        add_field => { "performance_category" => "fast" }
      }
    }
  }

  # Парсинг timestamp
  date {
    match => [ "timestamp", "ISO8601" ]
    target => "@timestamp"
    timezone => "UTC"
  }
}

output {
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "advanced-logs-%{+YYYY.MM.dd}"
  }
  stdout { codec => rubydebug }
}

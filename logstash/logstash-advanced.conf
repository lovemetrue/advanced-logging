input {
  file {
    path => "/var/log/app/*.log"
    start_position => "beginning"
    sincedb_path => "/dev/null"
    codec => multiline {
      pattern => "^%{TIMESTAMP_ISO8601}"
      negate => true
      what => "previous"
    }
  }
}

filter {
  # Кастомные grok паттерны
  grok {
    patterns_dir => ["/usr/share/logstash/patterns"]
    match => { 
      "message" => "%{TIMESTAMP_ISO8601:timestamp} %{LOGLEVEL:level} \[%{DATA:thread}\] %{DATA:class} - %{GREEDYDATA:message}" 
    }
  }

  # Парсинг сложных JSON с вложенными объектами
  if [message] =~ /^{.*}$/ {
    json {
      source => "message"
      target => "parsed_json"
    }
    
    # Извлечение вложенных полей
    if [parsed_json][request] {
      mutate {
        add_field => {
          "http_method" => "%{[parsed_json][request][method]}"
          "http_url" => "%{[parsed_json][request][url]}"
          "user_agent" => "%{[parsed_json][request][headers][user_agent]}"
        }
      }
    }
  }

  # Парсинг логов баз данных
  grok {
    match => { 
      "message" => "(?<db_timestamp>%{YEAR}-%{MONTHNUM}-%{MONTHDAY} %{TIME}) %{WORD:db_operation} %{WORD:db_table}.*Duration: %{NUMBER:duration}ms" 
    }
  }

  # Валидация и нормализация
  if [duration] {
    mutate {
      convert => { "duration" => "integer" }
    }
    
    # Категоризация по длительности
    if [duration] > 1000 {
      mutate {
        add_field => { "performance" => "slow" }
      }
    } else if [duration] > 500 {
      mutate {
        add_field => { "performance" => "medium" }
      }
    } else {
      mutate {
        add_field => { "performance" => "fast" }
      }
    }
  }
}

output {
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "advanced-logs-%{+YYYY.MM.dd}"
  }
  stdout { codec => rubydebug }
}

filter {
  # Генерация уникального ID для каждого события если его нет
  if ![correlation_id] {
    uuid {
      target => "correlation_id"
    }
  }

  # Добавление геоданных по IP
  if [client_ip] {
    geoip {
      source => "client_ip"
      target => "geoip"
      database => "/usr/share/logstash/GeoLite2-City.mmdb"
      default_database_type => "City"
    }
    
    # Добавление информации об организации по IP
    geoip {
      source => "client_ip"
      target => "asn"
      database => "/usr/share/logstash/GeoLite2-ASN.mmdb"
      default_database_type => "ASN"
    }
  }

  # Обогащение пользовательскими данными (пример с статическим mapping)
  translate {
    field => "user_id"
    destination => "user_info"
    dictionary => {
      "user123" => '{"name":"John Doe","role":"admin","department":"IT"}'
      "user456" => '{"name":"Jane Smith","role":"user","department":"Sales"}'
      "user789" => '{"name":"Bob Wilson","role":"manager","department":"Marketing"}'
    }
    fallback => '{"name":"Unknown","role":"guest","department":"Unknown"}'
    refresh_interval => 300
  }

  # Парсинг user_info из JSON строки
  if [user_info] {
    json {
      source => "user_info"
      target => "user"
    }
  }

  # Добавление бизнес-контекста на основе кодов ответов
  translate {
    field => "http_status"
    destination => "status_category"
    dictionary => {
      "200" => "success"
      "201" => "success"
      "202" => "success"
      "204" => "success"
      "400" => "client_error"
      "401" => "auth_error"
      "403" => "auth_error"
      "404" => "client_error"
      "409" => "client_error"
      "500" => "server_error"
      "502" => "server_error"
      "503" => "server_error"
      "504" => "server_error"
    }
    fallback => "unknown"
  }

  # Корреляция событий по correlation_id
  if [correlation_id] {
    # Поиск связанных логов за последние 10 минут
    elasticsearch {
      hosts => ["elasticsearch:9200"]
      query => "correlation_id:%{[correlation_id]} AND @timestamp:[now-10m TO now]"
      fields => {
        "[@timestamp]" => "related_timestamp"
        "level" => "related_level"
        "message" => "related_message"
        "service" => "related_service"
      }
      target => "related_events"
      docinfo => true
      sort => "@timestamp:desc"
      size => 5
    }
    
    # Подсчет количества связанных событий
    if [related_events][hits] {
      ruby {
        code => "event.set('related_events_count', event.get('related_events')['hits']['total']['value'])"
      }
    }
  }

  # Добавление контекста времени (рабочее/нерабочее время)
  ruby {
    code => '
      time = event.get("@timestamp")
      hour = time.time.localtime.hour
      
      if hour >= 9 && hour < 18
        event.set("time_context", "business_hours")
      else
        event.set("time_context", "off_hours")
      end
      
      # Добавляем день недели
      event.set("day_of_week", time.time.localtime.strftime("%A"))
    '
  }

  # Агрегация метрик для мониторинга производительности
  metrics {
    meter => ["http_requests"]
    add_tag => "metric"
    flush_interval => 30
    clear_interval => 300
    rates => [1, 5]
  }

  # Агрегация по типам ошибок
  metrics {
    meter => ["errors_by_type"]
    add_tag => "error_metric"
    key => "exception_class"
    flush_interval => 60
    clear_interval => 600
  }

  # Добавление тегов на основе анализа контента
  if [message] =~ /(error|exception|failed|failure)/i {
    mutate {
      add_tag => ["has_error"]
    }
  }

  if [message] =~ /(slow|timeout|latency|performance)/i {
    mutate {
      add_tag => ["performance_issue"]
    }
  }

  if [message] =~ /(security|auth|permission|access)/i {
    mutate {
      add_tag => ["security_related"]
    }
  }
}

output {
  if "metric" in [tags] {
    elasticsearch {
      hosts => ["elasticsearch:9200"]
      index => "metrics-%{+YYYY.MM.dd}"
    }
  } else {
    elasticsearch {
      hosts => ["elasticsearch:9200"]
      index => "enriched-logs-%{+YYYY.MM.dd}"
    }
  }
}
